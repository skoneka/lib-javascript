<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: connection/ConnectionEvents.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: connection/ConnectionEvents.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>var utility = require('../utility/utility.js'),
  _ = require('underscore'),
  Filter = require('../Filter'),
  Event = require('../Event'),
  CC = require('./ConnectionConstants.js');

/**
 * @class ConnectionEvents
 *
 * Coverage of the API
 *  GET /events -- 100%
 *  POST /events -- only data (no object)
 *  POST /events/start -- 0%
 *  POST /events/stop -- 0%
 *  PUT /events/{event-id} -- 100%
 *  DELETE /events/{event-id} -- only data (no object)
 *  POST /events/batch -- only data (no object)
 *
 *  attached files manipulations are covered by Event
 *
 *
 * @param {Connection} connection
 * @constructor
 */
function ConnectionEvents(connection) {
  this.connection = connection;
}


/**
 * @example
 * // get events from the Diary stream
 * conn.events.get({streamId : 'diary'},
 *  function(events) {
 *    console.log('got ' + events.length + ' events)
 *  }
 * );
 * @param {FilterLike} filter
 * @param {ConnectionEvents~getCallback} doneCallback
 * @param {ConnectionEvents~partialResultCallback} partialResultCallback
 */
ConnectionEvents.prototype.get = function (filter, doneCallback, partialResultCallback) {
  //TODO handle caching
  var result = [];
  filter = filter || {};
  this._get(filter, function (error, res) {
    if (error) {
      result = null;
    } else {
      var eventList = res.events || res.event;
      _.each(eventList, function (eventData) {

        var event = null;
        if (!this.connection.datastore) { // no datastore   break
          event = new Event(this.connection, eventData);
        } else {
          event = this.connection.datastore.createOrReuseEvent(eventData);
        }

        result.push(event);

      }.bind(this));
    }
    doneCallback(error, result);

    if (partialResultCallback) { partialResultCallback(result); }
  }.bind(this));

};

/**
 * @param {Event} event
 * @param {Connection~requestCallback} callback
 */
ConnectionEvents.prototype.update = function (event, callback) {
  this._updateWithIdAndData(event.id, event.getData(), callback);
};

/**
 * @param {Event | eventId} event
 * @param {Connection~requestCallback} callback
 */
ConnectionEvents.prototype.delete = ConnectionEvents.prototype.trash = function (event, callback) {
  this.trashWithId(event.id, callback);
};

/**
 * @param {String} eventId
 * @param {Connection~requestCallback} callback
 */
ConnectionEvents.prototype.trashWithId = function (eventId, callback) {
  var url = '/events/' + eventId;
  this.connection.request('DELETE', url, function (error, result) {
    // assume there is only one event (no batch for now)
    if (result && result.event) {
      if (! this.connection.datastore) { // no datastore   break
        result = new Event(this.connection, result.event);
      } else {
        result = this.connection.datastore.createOrReuseEvent(result.event);
      }
    }  else {
      result = null;
    }
    if (callback && typeof(callback) === 'function') {
      callback(error, result);
    }
  }.bind(this), null);
};

/**
 * This is the preferred method to create an event, or to create it on the API.
 * The function return the newly created object.. It will be updated when posted on the API.
 * @param {NewEventLike} event -- minimum {streamId, type } -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {Boolean} [start = false] if set to true will POST the event to /events/start
 * @return {Event} event
 */
ConnectionEvents.prototype.create = function (newEventlike, callback) {
  _create.call(this, newEventlike, callback, false);
};


/**
 * This is the preferred method to create and start an event, Starts a new period event.
 * This is equivalent to starting an event with a null duration. In singleActivity streams,
 * also stops the previously running period event if any.
 * @param {NewEventLike} event -- minimum {streamId, type } -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @return {Event} event
 */
ConnectionEvents.prototype.start = function (newEventlike, callback) {
  _create.call(this, newEventlike, callback, true);
};


// common call for create and start
function _create(newEventlike, callback, start) {
  var event = null;
  if (newEventlike instanceof Event) {
    if (newEventlike.connection !== this.connection) {
      return callback(new Error('event.connection does not match current connection'));
    }
    if (newEventlike.id) {
      return callback(new Error('cannot create an event already existing on the API'));
    }
    event = newEventlike;
  } else {
    event = new Event(this.connection, newEventlike);
  }

  var url = '/events';
  if (start) { url = '/events/start'; }


  this.connection.request('POST', url, function (err, result, resultInfo) {
    if (! err && resultInfo.code !== 201) {
      err = {id : CC.Errors.INVALID_RESULT_CODE};
    }
    /**
     * Change will happend with offline caching...
     *
     * An error may hapend 400.. or other if app is behind an non-opened gateway. Thus making
     * difficult to detect if the error is a real bad request.
     * The first step would be to consider only bad request if the response can be identified
     * as coming from a valid api-server. If not, we should cache the event for later synch
     * then remove the error and send the cached version of the event.
     *
     */
    // TODO if err === API_UNREACHABLE then save event in cache
    if (result && ! err) {
      _.extend(event, result.event);
      if (this.connection.datastore) {  // if datastore is activated register new event
        this.connection.datastore.addEvent(event);
      }
    }
    if (_.isFunction(callback)) {

      callback(err, err ? null : event);
    }
  }.bind(this), event.getData());
  return event;
}




/**
 * Stop an event by it's Id
 * @param {EventLike} event -- minimum {id} -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {Date} [date = now] the date to set to stop the event
 * @param {ConnectionEvents~eventStoppedOnTheAPI} callback
 * @return {Event} event
 */
ConnectionEvents.prototype.stopEvent = function (eventlike, date, callback) {
  var url = '/events/stop';

  var data = {id : eventlike.id };
  if (date) { data.time = date.getTime() / 1000; }


  this.connection.request('POST', url, function (err, result, resultInfo) {
    if (! err && resultInfo.code !== 200) {
      err = {id : CC.Errors.INVALID_RESULT_CODE};
    }


    // TODO if err === API_UNREACHABLE then save event in cache
    /*
    if (result && ! err) {
      if (this.connection.datastore) {  // if datastore is activated register new event

      }
    } */
    if (_.isFunction(callback)) {
      callback(err, err ? null : result.stoppedId);
    }
  }.bind(this), data);
};



/**
 * Stop any event in this stream
 * @param {StreamLike} stream -- minimum {id} -- if typeof Stream, must belong to
 * the same connection and not exists on the API.
 * @param {Date} [date = now] the date to set to stop the event
 * @param {String} [type = null] stop any matching eventType is this stream.
 * @param {ConnectionEvents~eventStoppedOnTheAPI} callback
 * @return {Event} event
 */
ConnectionEvents.prototype.stopStream = function (streamLike, date, type, callback) {
  var url = '/events/stop';

  var data = {streamId : streamLike.id };
  if (date) { data.time = date.getTime() / 1000; }
  if (type) { data.type = type; }


  this.connection.request('POST', url, function (err, result, resultInfo) {
    if (! err && resultInfo.code !== 200) {
      err = {id : CC.Errors.INVALID_RESULT_CODE};
    }

    // TODO if err === API_UNREACHABLE then cache the stop instruction for later synch

    if (_.isFunction(callback)) {
      callback(err, err ? null : result.stoppedId);
    }
  }.bind(this), data);
};


/**
 * @param {NewEventLike} event -- minimum {streamId, type } -- if typeof Event, must belong to
 * the same connection and not exists on the API.
 * @param {ConnectionEvents~eventCreatedOnTheAPI} callback
 * @param {FormData} the formData to post for fileUpload. On node.js
 * refers to pryv.utility.forgeFormData
 * @return {Event} event
 */
ConnectionEvents.prototype.createWithAttachment =
  function (newEventLike, formData, callback, progressCallback) {
    var event = null;
    if (newEventLike instanceof Event) {
      if (newEventLike.connection !== this.connection) {
        return callback(new Error('event.connection does not match current connection'));
      }
      if (newEventLike.id) {
        return callback(new Error('cannot create an event already existing on the API'));
      }
      event = newEventLike;
    } else {
      event = new Event(this.connection, newEventLike);
    }
    formData.append('event', JSON.stringify(event.getData()));
    var url = '/events';
    this.connection.request('POST', url, function (err, result) {
      if (result) {
        _.extend(event, result.event);

        if (this.connection.datastore) {  // if datastore is activated register new event
          this.connection.datastore.addEvent(event);
        }

      }
      callback(err, event);
    }.bind(this), formData, true, progressCallback);
  };
ConnectionEvents.prototype.addAttachment = function (eventId, file, callback, progressCallback) {
  var url = '/events/' + eventId;
  this.connection.request('POST', url, callback, file, true, progressCallback);
};
ConnectionEvents.prototype.removeAttachment = function (eventId, fileName, callback) {
  var url = '/events/' + eventId + '/' + fileName;
  this.connection.request('DELETE', url, callback);
};
/**
 * //TODO rename to batch
 * //TODO make it NewEventLike compatible
 * //TODO once it support an array of mixed values Event and EventLike, the, no need for
 *  callBackWithEventsBeforeRequest at it will. A dev who want Event object just have to create
 *  them before
 * This is the prefered method to create events in batch
 * @param {Object[]} eventsData -- minimum {streamId, type }
 * @param {ConnectionEvents~eventBatchCreatedOnTheAPI}
 * @param {function} [callBackWithEventsBeforeRequest] mostly for testing purposes
 * @return {Event[]} events
 */
ConnectionEvents.prototype.batchWithData =
  function (eventsData, callback, callBackWithEventsBeforeRequest) {
    if (!_.isArray(eventsData)) { eventsData = [eventsData]; }

    var createdEvents = [];
    var eventMap = {};

    var url = '/';
    // use the serialId as a temporary Id for the batch
    _.each(eventsData, function (eventData, i) {

      var event =  new Event(this.connection, eventData);

      createdEvents.push(event);
      eventMap[i] = event;
    }.bind(this));

    if (callBackWithEventsBeforeRequest) {
      callBackWithEventsBeforeRequest(createdEvents);
    }

    var mapBeforePush = function (evs) {
      return _.map(evs, function (e) {
        return {
          method: 'events.create',
          params: e
        };
      });
    };

    this.connection.request('POST', url, function (err, result) {
      if (!err && result) {
        _.each(result.results, function (eventData, i) {
          _.extend(eventMap[i], eventData.event); // add the data to the event

          if (this.connection.datastore) {  // if datastore is activated register new event
            this.connection.datastore.addEvent(eventMap[i]);
          }


        }.bind(this));
      }
      callback(err, createdEvents);
    }.bind(this), mapBeforePush(eventsData));

    return createdEvents;
  };

// --- raw access to the API

/**
 * TODO anonymise by renaming to function _get(..
 * @param {FilterLike} filter
 * @param {Connection~requestCallback} callback
 * @private
 */
ConnectionEvents.prototype._get = function (filter, callback) {
  var tParams = filter;
  if (filter instanceof Filter) { tParams = filter.getData(true); }
  if (_.has(tParams, 'streams') && tParams.streams.length === 0) { // dead end filter..
    return callback(null, []);
  }
  var url = '/events?' + utility.getQueryParametersString(tParams);
  this.connection.request('GET', url, callback, null);
};


/**
 * TODO anonymise by renaming to function _xx(..
 * @param {String} eventId
 * @param {Object} data
 * @param  {Connection~requestCallback} callback
 * @private
 */
ConnectionEvents.prototype._updateWithIdAndData = function (eventId, data, callback) {
  var url = '/events/' + eventId;
  this.connection.request('PUT', url, function (error, result) {
    if (!error && result && result.event) {
      if (!this.connection.datastore) {
        result = new Event(this.connection, result.event);
      } else {
        result = this.connection.datastore.createOrReuseEvent(result.event);
      }
    } else {
      result = null;
    }
    if (callback && typeof(callback) === 'function') {
      callback(error, result);
    }
  }.bind(this), data);
};


/**
 * @private
 * @param {Event} event
 * @param {Object} the data to map
 */
ConnectionEvents.prototype._registerNewEvent = function (event, data) {


  if (! event.connection.datastore) { // no datastore   break
    _.extend(event, data);
    return event;
  }

  return event.connection.datastore.createOrReuseEvent(this, data);
};

module.exports = ConnectionEvents;

/**
 * Called with the desired Events as result.
 * @callback ConnectionEvents~getCallback
 * @param {Object} error - eventual error
 * @param {Event[]} result
 */


/**
 * Called each time a "part" of the result is received
 * @callback ConnectionEvents~partialResultCallback
 * @param {Event[]} result
 */


/**
 * Called when an event is created on the API
 * @callback ConnectionEvents~eventCreatedOnTheAPI
 * @param {Object} error - eventual error
 * @param {Event} event
 */

/**
 * Called when an event is created on the API
 * @callback ConnectionEvents~eventStoppedOnTheAPI
 * @param {Object} error - eventual error
 * @param {String} stoppedEventId or null if event not found
 */

/**
 * Called when batch create an array of events on the API
 * @callback ConnectionEvents~eventBatchCreatedOnTheAPI
 * @param {Object} error - eventual error
 * @param {Event[]} events
 */
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="Accesses.html">Accesses</a></li><li><a href="Auth.html">Auth</a></li><li><a href="Bookmarks.html">Bookmarks</a></li><li><a href="Connection.html">Connection</a></li><li><a href="ConnectionEvents.html">ConnectionEvents</a></li><li><a href="ConnectionStreams.html">ConnectionStreams</a></li><li><a href="Event.html">Event</a></li><li><a href="Filter.html">Filter</a></li><li><a href="Monitor.html">Monitor</a></li><li><a href="Profile.html">Profile</a></li><li><a href="URLInfo.html">URLInfo</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_">_</a></li><li><a href="global.html#eventTypes">eventTypes</a></li><li><a href="global.html#FormData">FormData</a></li><li><a href="global.html#getPreferredLanguage">getPreferredLanguage</a></li><li><a href="global.html#isValidExtrasFile">isValidExtrasFile</a></li><li><a href="global.html#isValidTypesFile">isValidTypesFile</a></li><li><a href="global.html#loadExternalFiles">loadExternalFiles</a></li><li><a href="global.html#parseResponseHeaders">parseResponseHeaders</a></li><li><a href="global.html#Stream">Stream</a></li><li><a href="global.html#supportCSS3">supportCSS3</a></li><li><a href="global.html#utility">utility</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Mon Mar 09 2015 13:48:25 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
